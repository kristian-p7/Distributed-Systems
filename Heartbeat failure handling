
# Sendet heartbeat messages und wartet auf Antwort -> zählt fehlende Antworten und informiert über fehlende Peers
class HeartbeatSender(Thread):
    def __init__(self):
        Thread.__init__(self)
        self.running = True
        self.uport = TCP_UNICAST_PORT
        self.UUID = UUID
        self.hostname = socket.gethostname()
        self.ip_address = ipaddress
        

        self.msg = {
            "cmd": "HEARTBEAT",
            "uuid": str(self.UUID),
            "msg": self.ip_address
        }

    def terminate(self):
        self.running = False

    # Sendet den Heartbeat in Sekundenintervallen
    def run(self):
        while self.running:
            self.sendMessage(find_neighbors(self.ip_address), self.uport, self.msg, "right") #überprüft, ob Veränderungen bei den Neighbours auftreten
            time.sleep(1)
        pass
       
# Sendet Message und identifiziert Fehler
    def sendMessage(self, neighbor,uport):

        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            #print(neighbor[0], uport)
            s.connect_ex((neighbor[0], uport))
            s.sendall(decodeMessage)  #checkmessage an alle
            data = decodeMessage
            #time.sleep(1)
            if not data:
                if right_neighbor  == True:
                    self.counterRight = my_index
                    if debug: print("Right neighbor counter 'no data' +1")
                elif left_neighbor == True:
                    self.counterLeft = my_index    
                    if debug: print("Left neighbor counter 'no data' +1")
                return
            
        finally:
            s.close

        # Wie auf "missing neighbours" reagiert wird, links rechts 
        if self.counterLeft < 3 :   # ursprünglich > 3, 
            if debug: print("Left neighbor lost: ", neighbor)
            self.sendLostPeerMessage(neighbor)
            self.counterLeft = 0
            pass
        if self.counterRight < 3 :  # ursprünglich > 3
            if debug: print("Right neighbor lost: ", neighbor)
            self.sendLostPeerMessage(neighbor)
            self.counterRight = 0
        pass

    # Handling lost peers, LostPeerMesage bearbeiten !!!!!!
    def sendLostPeerMessage(self, neighbor):
        global leaderIpAndUUID #identidizierung des Leaders Platzhalter
        global leader
        global BSender

        # FALL 1: Leader got lost. --> Detecting peer takes temporary leader role, broadcasts the lost leader and starts new leader voting
        if neighbor[0] == leaderIpAndUUID[0]:
            
            if debug: print("The leader is lost. This peer will be the temprary leader.")
            
            leader = True

            msgLostPeer = {
                "cmd": "LOST_PEER",
                "uuid": neighbor[1],
                "msg": neighbor[0]
            }

            BSender.broadcast(BSender.bcip, BSender.bcport, msgLostPeer)

            time.sleep(1)

            vote = Voting()
            vote.startVote()

        # FALL2: Peer lost  ->   The detecting peer informs the leader about the lost peer
        else:
            
            if debug: print("Inform the leader that one neighbor is lost")
            msgLostNeighbor = {
                        "cmd": "LOST_NEIGHBOR",
                        "uuid": neighbor[1],
                        "msg": neighbor[0]
                    }

            TCPUnicastSender(self.UUID, leaderIpAndUUID[0], msgLostNeighbor)




